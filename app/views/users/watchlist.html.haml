- title "#{@user.name}'s Anime Library"

.large-12.columns.option-bar.hide-for-small
  .small-6.large-2.columns
    %p.option-title Anime Library


  .small-12.large-9.columns.options
    %ul.status-tabs.inline-list
      %li.active#tab-all= link_to "All", "#all", onclick: "showRelevantSections('all')"
      - Watchlist.valid_statuses.each do |status|
        %li{:id => "tab-" + status.parameterize}= link_to status, "##{status.parameterize}", onclick: "showRelevantSections(#{status.parameterize.inspect})"


- Watchlist.valid_statuses.each do |status|
  .watchlist-row{:id => "table-" + status.parameterize}
    .large-12.columns.library-status-header
      %h5.status
        = status
        %span.item-count.pull-right
    .row
      .large-12.columns.library-table

%script(type="text/template" id="WatchlistSectionViewTemplate")
  %table.large-12.columns.fake-table-row
    %thead
      %tr.sortOptions
        %th{:width => "495"}
          %a(data-sortparam="title") 
            Title
            %i.icon.icon-sort
        %th{:width => "95"}
          %a(data-sortparam="progress") 
            Progress
            %i.icon.icon-sort
        %th{:width => "76"}
          %a(data-sortparam="rating") 
            Rating
            %i.icon.icon-sort
        %th{:width => "65"}
          %a(data-sortparam="type") 
            Type
            %i.icon.icon-sort

    %tbody.fake-table-row.library-item

    %tbody.loading-indicator
      %tr
        %td.center(colspan=4 style="color: #333")
          %i.icon.icon-spin.icon-spinner.icon-2x
          %span.right(style="color: #aaa; padding-top: 10px")
            (Finished loading <span>0</span> entries.)

%script(type="text/template" id="WatchlistItemViewTemplate")
  %td.library-item-title{:width => "495"}
    .relative-wrapper
      %a{:href => "{{anime.url}}"} {{anime.title}}
      {{#private}}
      %span.item-indicator
        &#8901;
        %i.icon-eye-close 
      {{/private}}
      {{#notes_present}}
      %span.item-indicator
        &#8901;
        %span.has-tip(data-tooltip){:title => "{{notes}}"}
          %i.icon-book
      {{/notes_present}}
      %i.icon-reorder
  %td.episode-count{:width => "95"}
    .relative-wrapper 
      - if @user == current_user
        %a.click-add
          %i.icon-angle-up
      %span.edit {{episodes_watched}}
      %span.hide-small / {{anime.episode_count}}

  %td{:width => "76"} 
    %span.select
      - if @user.star_rating
        %i.icon-star
        {{rating.value}}
      - else
        {{#rating.positive}}
        %span.positive-smiley :)
        {{/rating.positive}}
        {{#rating.neutral}}
        %span.neutral-smiley :|
        {{/rating.neutral}}
        {{#rating.negative}}
        %span.negative-smiley :(
        {{/rating.negative}}
        {{#rating.unknown}}
        %span.unknown-smiley --
        {{/rating.unknown}}
  %td{:width => "65"} {{anime.show_type}}
  
%script(type="text/template" id="WatchlistDropdownTemplate")
  %tr.library-dropdown
    %td{:style => "background: #fafafa;"}(colspan=4)
      .large-8.columns.meta-content
        .large-12.columns.last-update
          %p Last Library Update: {{formattedLastUpdateTime}}
        .large-4.columns.thumbnail.hide-for-small
          %img(src="{{anime.cover_image}}")
        
        // Left side of dropdown with thumbnail and description
        .large-8.columns.library-item-info
          %span.title {{anime.title}}
          .rating
          %span.description {{anime.short_synopsis}}
          %span.description-link
            %a(style="color: #fd864b" href="{{anime.url}}") [Read More]

      // Right side of dropdown with update content
      - if @user == current_user
        .large-4.columns.action-area
          .opacity-wrapper
            %form.custom
              .large-12.columns.library-status
                .large-3.columns.option-label
                  %span Status:
                .large-9.columns.status-dropdown
                  %select.medium(name="status")
                    - Watchlist.valid_statuses.each do |status|
                      %option{:value => status.parameterize}= status

              .large-12.columns.episodes-watched
                .large-3.columns.option-label
                  %span Watched:
                .large-9.columns.status-dropdown
                  .small-6.large-6.columns.episode-input
                    %input(name="episodes_watched" type="number" value="{{episodes_watched}}" min="0" max="{{anime.episode_count}}")
                  .small-6.large-6.columns.end.episode-count
                    %span.postfix Out of {{anime.episode_count}}

              .large-12.columns.episodes-watched
                .large-3.columns.option-label
                  %span Rewatched:
                .large-7.columns.status-dropdown
                  .small-6.large-6.columns.episode-input
                    %input(name="rewatched_times" type="number" value="{{rewatched_times}}" min="0")
                  .small-6.large-6.columns.end.episode-count
                    %span.postfix Times

              .large-12.columns.privacy-setting
                .large-3.columns.option-label
                  %span Privacy:
                .large-9.columns.privacy-dropdown
                  %select.medium(name="privacy")
                    %option(value="public") Public
                    %option(value="private") Private

            .large-12.columns.remove-from-library.text-center
              %span
                %i.icon-remove
                %a.remove-from-library Remove From Library
        // Spinner
        %span.updating-icon.hide
          %i.icon-spinner.icon-spin.updating-icon
      - else
        / Guest View
        / TODO
      
      .large-12.columns
        - if @user == current_user
          %form.notes-form
            .row
              .small-12
                %textarea{:placeholder => "Personal Notes about {{anime.title}}", :class => "personal-notes", :name => "notes"} {{notes}}
                %small.error.saving-indicator(style="display:none")
                  %i.icon.icon-spin.icon-spinner
                  Saving...

:coffee
  starRatings = #{@user.star_rating.inspect}
  currentUsersProfile = #{@user == current_user}

  setActiveTab = (section) ->
    $(".option-bar .options li").removeClass "active"
    $(".option-bar .options #tab-" + section).addClass "active"

  WatchlistSections = #{Watchlist.valid_statuses.map {|x| x.parameterize }.inspect}
    
  @showRelevantSections = (x...) ->
    section = if x[0] then x[0] else window.location.hash.substring(1)
    if _.contains WatchlistSections, section
      setActiveTab section
      $(".watchlist-row").hide()
      $("#table-" + section).show()
    else
      setActiveTab "all"
      $(".watchlist-row").show()
      
  showRelevantSections()

  # Models and Collections
  WatchlistItem = Backbone.Model.extend
    update: (data) ->
      if currentUsersProfile
        data.anime_id = this.get("anime").slug
        that = this
        $.post "/api/v1/libraries/" + data.anime_id, data, (d) ->
          newModel = that.updateSelf(d)
          if that.get("_dropdownOpen")
            newModel.set "_dropdownOpen", true
      
    updateSelf: (d) ->
      oldSection = this.get("status_parameterized")
      newSection = d.status_parameterized
      oldModel = this
      newModel = new WatchlistItem d
      options = {}
      if newSection == oldSection
        options.at = WatchlistSectionCollections[oldSection].indexOf oldModel
      WatchlistSectionCollections[oldSection].remove oldModel
      WatchlistSectionCollections[newSection].add newModel, options
      WatchlistSectionViews[newSection].renderContents()
      return WatchlistSectionCollections[newSection].get d.id

  negateString = (str) ->
    str = _.map str.toLowerCase().split(""), (l) ->
      return String.fromCharCode(-(l.charCodeAt(0)));
    return str

  WatchlistSectionCollections = {}
  WatchlistSectionCollectionClass = Backbone.Collection.extend
    sortByParameter: "lastWatchedDesc"
    comparator: (c) ->
      if this.sortByParameter == "lastWatchedDesc"
        if c.get("last_watched")
          return -moment(c.get("last_watched")).unix()
        else
          return -moment(c.get("updated_at")).unix()
      else if this.sortByParameter == "title"
        return c.get("anime").title
      else if this.sortByParameter == "titleDesc"
        return negateString c.get("anime").title
      else if this.sortByParameter == "progress"
        return c.get("episodes_watched")
      else if this.sortByParameter == "progressDesc"
        return -c.get("episodes_watched")
      else if this.sortByParameter == "rating"
        if c.get("rating").value == "-"
          return 0
        else
          return c.get("rating").value
      else if this.sortByParameter == "ratingDesc"
        if c.get("rating").value == "-"
          return 0
        else
          return -c.get("rating").value
      else if this.sortByParameter == "type"
        return c.get("anime").show_type
      else if this.sortByParameter == "typeDesc"
        return negateString c.get("anime").show_type
  _.each WatchlistSections, (s) ->
    WatchlistSectionCollections[s] = new WatchlistSectionCollectionClass []

  # Views
  WatchlistItemView = Backbone.View.extend
    tagName: "tr"
    template: Hogan.compile $("#WatchlistItemViewTemplate").html()
    dropdownTemplate: Hogan.compile $("#WatchlistDropdownTemplate").html()

    initialize: ->
      _(this).bindAll 'remove', 'change'
      this.model.bind 'remove', this.remove
      this.model.bind 'change', this.change

    remove: ->
      if this.model.get("_dropdownOpen")
        this.hideDropdown()
      this.$el.remove()

    change: ->
      if this.model.get("_dropdownOpen")
        this.showDropdown()
      else
        this.hideDropdown()
    
    render: ->
      this.model.set "formattedLastUpdateTime", moment(this.model.get("last_watched")).format('MMMM Do YYYY')
      this.$el.html this.template.render this.model.toJSON()
      that = this
      this.$el.find("td:first").click ->
        that.toggleDropdown()
      this.$el.find("a.click-add").click ->
        that.$el.find("a.click-add").replaceWith $("<i class='icon icon-spin icon-spinner'></i>")
        that.model.update {increment_episodes: true}
      return this
      
    showDropdown: ->
      that = this
      WatchlistSectionCollections[this.model.get("status_parameterized")].find (m) ->
        if m.get("_dropdownOpen") and m.get("_id") != that.model.get("_id")
          m.set "_dropdownOpen", false
      this.$el.after this.dropdownTemplate.render this.model.toJSON()
      this.$dropdown = this.$el.next()

      # Write rating to the dropdown.
      dropdown_ratings = this.$dropdown.find ".rating"
      dropdown_ratings.empty()
      rating = this.model.get("rating")
      if starRatings
        for i in [-2..2]
          star = $("<a class='star' data-rating='" + i + "'></a>")
          if rating.value >= i + 3
            star.append $("<i class='icon-star'></i>")
          else
            star.append $("<i class='icon-star-empty'></i>")
          star.click -> 
            dropdown_ratings.append $("<i class='icon icon-spin icon-spinner'></i>")
            that.model.update {rating: $(this).attr("data-rating")}
          dropdown_ratings.append star
      else
        m = {
          positive: "<span class='positive-smiley'>:)</span>", 
          neutral: "<span class='neutral-smiley'>:|</span>", 
          negative: "<span class='negative-smiley'>:(</span>"
        }
        v = {positive: 2, neutral: 0, negative: -2}
        for t in ['positive', 'neutral', 'negative']
          q = $("<a data-rating='" + v[t] + "'>" + m[t] + "</a>")
          q.click ->
            dropdown_ratings.append $("<i class='icon icon-spin icon-spinner'></i>")
            that.model.update {rating: $(this).attr("data-rating")}
          if rating[t]
            dropdown_ratings.append $("<strong></strong>").append q
          else
            dropdown_ratings.append q

      # Set status and privacy.
      this.$dropdown.find("option[value=" + this.model.get("status_parameterized") + "]").attr("selected", "selected")
      this.$dropdown.find("option[value=" + (if this.model.get("private") then "private" else "public") + "]").attr("selected", "selected")

      that = this
      # Activate "Remove from Library" button.
      this.$dropdown.find(".remove-from-library").click ->
        that.dropdownLoading()

        $.post "/watchlist/remove", {anime_id: that.model.get("anime").slug}, (d) ->
          if d
            status = that.model.get("status_parameterized")
            WatchlistSectionCollections[status].remove that.model
            WatchlistSectionViews[status].renderContents()

      # Submit updates when needed.
      this.$dropdown.find("form.custom").submit -> that.submitDropdownForm()
      this.$dropdown.find("form.custom").change -> that.submitDropdownForm()

      # Submit notes form.
      this.$dropdown.find("form.notes-form").change ->
        that.$dropdown.find("form.notes-form .saving-indicator").show()
        notes = that.$dropdown.find("form.notes-form textarea").val()
        that.model.update {"notes": notes}
    
    dropdownLoading: ->
      $(".opacity-wrapper").addClass("updating")
      $(".updating-icon").removeClass("hide")
        
    submitDropdownForm: ->
      this.dropdownLoading()
      data = {}
      _.each this.$dropdown.find("form.custom").serializeArray(), (x) ->
        data[x.name] = x.value
      this.model.update data
      return false

    hideDropdown: ->
      this.$el.next().slideUp().remove()

    toggleDropdown: ->
      if this.model.get("_dropdownOpen")
        this.model.set "_dropdownOpen", false
      else
        this.model.set "_dropdownOpen", true

  WatchlistSectionViewClass = Backbone.View.extend
    tagName: "div"
    template: Hogan.compile $("#WatchlistSectionViewTemplate").html()
    initialize: ->
      _(this).bindAll 'add', 'remove'
      this.collection.bind 'add', this.add
      this.collection.bind 'remove', this.remove
    add: (i) ->
      iv = new WatchlistItemView {model: i}
      i.set "_view", iv
      this.renderItemCount()
    remove: ->
      this.renderItemCount()
    renderItemCount: ->
      $("#table-" + this.options.section + " .item-count").text "(" + this.collection.length + ")"
    render: ->
      this.$el.html this.template.render()
      that = this
      this.$el.find(".sortOptions a").click ->
        param = $(this).attr("data-sortparam")
        that.setSortOrderToNext(param)
        
      $("#table-" + this.options.section + " .library-table").append this.el
      return this

    setSortOrder: (sortOrder) ->
      # Activate the relevant title and show the relevant icon.

      this.$el.find(".sortOptions a").removeClass("active")
      this.$el.find(".sortOptions a i.icon").removeClass("icon-sort-down").removeClass("icon-sort-up").addClass("icon-sort")

      if sortOrder.substr(-4) == "Desc"
        param = sortOrder.substr(0, sortOrder.length-4)
      else
        param = sortOrder
        
      anchor = this.$el.find(".sortOptions a[data-sortparam='" + param + "']")

      if sortOrder.substr(-4) == "Desc"
        anchor.find("i.icon").removeClass("icon-sort").addClass("icon-sort-down")
      else
        anchor.find("i.icon").removeClass("icon-sort").addClass("icon-sort-up")

      anchor.addClass("active")

      section = WatchlistSectionCollections[this.options.section]
      $.jStorage.set "sortOrder_"+this.options.section, sortOrder
      section.sortByParameter = sortOrder
      section.sort()
      this.renderContents()
      
    
    setSortOrderToNext: (param) ->
      section = WatchlistSectionCollections[this.options.section]

      if param == section.sortByParameter
        param = param + "Desc"
      else if param == section.sortByParameter.substr(0, section.sortByParameter.length - 4)
        param = "lastWatchedDesc"
        
      this.setSortOrder param
      
    renderContents: ->
      tbody = $("<tbody class='fake-table-row library-item'></tbody>")
      this.collection.each (i) ->
        tbody.append i.get("_view").render().el
      $("#table-" + this.options.section + " .library-item").replaceWith tbody

  # Bind each WatchlistSectionCollection to corresponding view.
  WatchlistSectionViews = {}
  _.each WatchlistSections, (s) ->
    WatchlistSectionViews[s] = new WatchlistSectionViewClass
      collection: WatchlistSectionCollections[s]
      section: s
    WatchlistSectionViews[s].render()
    if $.jStorage.get("sortOrder_" + s)
      WatchlistSectionViews[s].setSortOrder $.jStorage.get("sortOrder_" + s)

  lastRender = moment()
  perPage = #{@per_page}
  @fetchWatchlistSection = (s...) ->
    section = s[0]
    page = if s[1] then s[1] else 1
    watchlist_path = "/api/v1/users/#{@user.to_param}/library"
    $.getJSON(watchlist_path + "?status=" + section + "&page=" + page, (d) ->
      models = _.map d, (x) ->
        new WatchlistItem x
      WatchlistSectionCollections[section].set models, {remove: false}
      if d.length > 0
        $("#table-" + section + " .loading-indicator span span").text(page * perPage)
        fetchWatchlistSection section, page+1
      else
        WatchlistSectionViews[section].renderContents()
        $("#table-" + section + " .loading-indicator").hide())
      .error ->
        setTimeout('fetchWatchlistSection("' + section + '", ' + page + ')', 2000)

  _.each WatchlistSections, (s) ->
    fetchWatchlistSection(s)
