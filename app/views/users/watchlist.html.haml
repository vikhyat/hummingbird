- title "#{@user.name}'s Anime Library"

.large-12.columns.option-bar.hide-for-small
  .small-6.large-2.columns
    %p.option-title Anime Library


  .small-12.large-9.columns.options
    %ul.status-tabs.inline-list
      %li.active#tab-all= link_to "All", "#all", onclick: "showRelevantSections('all')"
      - Watchlist.valid_statuses.each do |status|
        %li{:id => "tab-" + status.parameterize}= link_to status, "##{status.parameterize}", onclick: "showRelevantSections(#{status.parameterize.inspect})"


- Watchlist.valid_statuses.each do |status|
  .watchlist-row{:id => "table-" + status.parameterize}
    .large-12.columns.library-status-header
      %h5.status
        = status
        %span.item-count.pull-right
    .row
      .large-12.columns.library-table

:coffee
  starRatings = #{@user.star_rating.inspect}
  @currentUsersProfile = #{@user == current_user}

  setActiveTab = (section) ->
    $(".option-bar .options li").removeClass "active"
    $(".option-bar .options #tab-" + section).addClass "active"

  WatchlistSections = #{Watchlist.valid_statuses.map {|x| x.parameterize }.inspect}
    
  @showRelevantSections = (x...) ->
    section = if x[0] then x[0] else window.location.hash.substring(1)
    if _.contains WatchlistSections, section
      setActiveTab section
      $(".watchlist-row").hide()
      $("#table-" + section).show()
    else
      setActiveTab "all"
      $(".watchlist-row").show()
      
  showRelevantSections()

  # Models and Collections
  WatchlistItem = Backbone.Model.extend
    defaults:
      currentUsersProfile: currentUsersProfile
    update: (data) ->
      if currentUsersProfile
        data.anime_id = this.get("anime").slug
        that = this
        $.post "/api/v1/libraries/" + data.anime_id, data, (d) ->
          newModel = that.updateSelf(d)
          if that.get("_dropdownOpen")
            newModel.set "_dropdownOpen", true
      
    updateSelf: (d) ->
      oldSection = this.get("status_parameterized")
      newSection = d.status_parameterized
      oldModel = this
      newModel = new WatchlistItem d
      options = {}
      if newSection == oldSection
        options.at = WatchlistSectionCollections[oldSection].indexOf oldModel
      WatchlistSectionCollections[oldSection].remove oldModel
      WatchlistSectionCollections[newSection].add newModel, options
      WatchlistSectionViews[newSection].renderContents()
      return WatchlistSectionCollections[newSection].get d.id

  negateString = (str) ->
    str = _.map str.toLowerCase().split(""), (l) ->
      return String.fromCharCode(-(l.charCodeAt(0)));
    return str

  WatchlistSectionCollections = {}
  WatchlistSectionCollectionClass = Backbone.Collection.extend
    sortByParameter: "lastWatchedDesc"
    comparator: (c) ->
      if this.sortByParameter == "lastWatchedDesc"
        if c.get("last_watched")
          return -moment(c.get("last_watched")).unix()
        else
          return -moment(c.get("updated_at")).unix()
      else if this.sortByParameter == "title"
        return c.get("anime").title.toLowerCase()
      else if this.sortByParameter == "titleDesc"
        return negateString c.get("anime").title.toLowerCase()
      else if this.sortByParameter == "progress"
        return c.get("episodes_watched")
      else if this.sortByParameter == "progressDesc"
        return -c.get("episodes_watched")
      else if this.sortByParameter == "rating"
        if c.get("rating").value == "-"
          return 0
        else
          return c.get("rating").value
      else if this.sortByParameter == "ratingDesc"
        if c.get("rating").value == "-"
          return 0
        else
          return -c.get("rating").value
      else if this.sortByParameter == "type"
        return c.get("anime").show_type
      else if this.sortByParameter == "typeDesc"
        return negateString c.get("anime").show_type
  _.each WatchlistSections, (s) ->
    WatchlistSectionCollections[s] = new WatchlistSectionCollectionClass []

  # Views
  WatchlistItemView = Backbone.View.extend
    tagName: "tr"
    template: HandlebarsTemplates["watchlists/item_view_template"]
    dropdownTemplate: HandlebarsTemplates["watchlists/dropdown_template"]

    initialize: ->
      _(this).bindAll 'remove', 'change'
      this.model.bind 'remove', this.remove
      this.model.bind 'change', this.change

    remove: ->
      if this.model.get("_dropdownOpen")
        this.hideDropdown()
      this.$el.remove()

    change: ->
      if this.model.get("_dropdownOpen")
        this.showDropdown()
      else
        this.hideDropdown()
    
    render: ->
      this.model.set "formattedLastUpdateTime", moment(this.model.get("last_watched")).format('MMMM Do YYYY')
      this.$el.html this.template this.model.toJSON()
      initializeProgressIncrement this.$el.find(".progress-updater")
      if this.$el.find("span.total-episodes").html() == "0"
        this.$el.find("span.total-episodes").html("?")
      that = this
      this.$el.find("td:first").click ->
        that.toggleDropdown()
      return this
      
    showDropdown: ->
      that = this
      WatchlistSectionCollections[this.model.get("status_parameterized")].find (m) ->
        if m.get("_dropdownOpen") and m.get("_id") != that.model.get("_id")
          m.set "_dropdownOpen", false
      this.$el.after this.dropdownTemplate this.model.toJSON()
      this.$dropdown = this.$el.next()

      # Write rating to the dropdown.
      dropdown_ratings = this.$dropdown.find ".rating"
      dropdown_ratings.empty()
      rating = this.model.get("rating")
      if starRatings
        for i in [1..5]
          star = $("<a class='star' data-rating='" + i + "'></a>")
          if rating.value >= i
            star.append $("<i class='icon-star'></i>")
          else
            star.append $("<i class='icon-star-empty'></i>")
          star.click -> 
            dropdown_ratings.append $("<i class='icon icon-spin icon-spinner'></i>")
            that.model.update {rating: $(this).attr("data-rating")}
          dropdown_ratings.append star
      else
        m = {
          positive: "<span class='positive-smiley'>:)</span>", 
          neutral: "<span class='neutral-smiley'>:|</span>", 
          negative: "<span class='negative-smiley'>:(</span>"
        }
        v = {positive: 5, neutral: 3, negative: 1}
        for t in ['positive', 'neutral', 'negative']
          q = $("<a data-rating='" + v[t] + "'>" + m[t] + "</a>")
          q.click ->
            dropdown_ratings.append $("<i class='icon icon-spin icon-spinner'></i>")
            that.model.update {rating: $(this).attr("data-rating")}
          if rating[t]
            dropdown_ratings.append $("<strong></strong>").append q
          else
            dropdown_ratings.append q

      # Set status and privacy.
      this.$dropdown.find("option[value=" + this.model.get("status_parameterized") + "]").attr("selected", "selected")
      this.$dropdown.find("option[value=" + (if this.model.get("private") then "private" else "public") + "]").attr("selected", "selected")

      that = this
      # Activate "Remove from Library" button.
      this.$dropdown.find(".remove-from-library").click ->
        that.dropdownLoading()

        $.post "/watchlist/remove", {anime_id: that.model.get("anime").slug}, (d) ->
          if d
            status = that.model.get("status_parameterized")
            WatchlistSectionCollections[status].remove that.model
            WatchlistSectionViews[status].renderContents()

      # Submit updates when needed.
      this.$dropdown.find("form.custom").submit -> that.submitDropdownForm()
      this.$dropdown.find("form.custom").change -> that.submitDropdownForm()

      # Submit notes form.
      this.$dropdown.find("form.notes-form").change ->
        that.$dropdown.find("form.notes-form .saving-indicator").show()
        notes = that.$dropdown.find("form.notes-form textarea").val()
        that.model.update {"notes": notes}
    
    dropdownLoading: ->
      $(".opacity-wrapper").addClass("updating")
      $(".updating-icon").removeClass("hide")
        
    submitDropdownForm: ->
      this.dropdownLoading()
      data = {}
      _.each this.$dropdown.find("form.custom").serializeArray(), (x) ->
        data[x.name] = x.value
      this.model.update data
      return false

    hideDropdown: ->
      this.$el.next().slideUp().remove()

    toggleDropdown: ->
      if this.model.get("_dropdownOpen")
        this.model.set "_dropdownOpen", false
      else
        this.model.set "_dropdownOpen", true

  WatchlistSectionViewClass = Backbone.View.extend
    tagName: "div"
    template: HandlebarsTemplates["watchlists/section_view_template"]
    initialize: ->
      _(this).bindAll 'add', 'remove'
      this.collection.bind 'add', this.add
      this.collection.bind 'remove', this.remove
    add: (i) ->
      iv = new WatchlistItemView {model: i}
      i.set "_view", iv
      this.renderItemCount()
    remove: ->
      this.renderItemCount()
    renderItemCount: ->
      $("#table-" + this.options.section + " .item-count").text "(" + this.collection.length + ")"
    render: ->
      this.$el.html this.template()
      that = this
      this.$el.find(".sortOptions a").click ->
        param = $(this).attr("data-sortparam")
        that.setSortOrderToNext(param)
        
      $("#table-" + this.options.section + " .library-table").append this.el
      return this

    setSortOrder: (sortOrder) ->
      # Activate the relevant title and show the relevant icon.

      this.$el.find(".sortOptions a").removeClass("active")
      this.$el.find(".sortOptions a i.icon").removeClass("icon-sort-down").removeClass("icon-sort-up").addClass("icon-sort")

      if sortOrder.substr(-4) == "Desc"
        param = sortOrder.substr(0, sortOrder.length-4)
      else
        param = sortOrder
        
      anchor = this.$el.find(".sortOptions a[data-sortparam='" + param + "']")

      if sortOrder.substr(-4) == "Desc"
        anchor.find("i.icon").removeClass("icon-sort").addClass("icon-sort-down")
      else
        anchor.find("i.icon").removeClass("icon-sort").addClass("icon-sort-up")

      anchor.addClass("active")

      section = WatchlistSectionCollections[this.options.section]
      $.jStorage.set "sortOrder_"+this.options.section, sortOrder
      section.sortByParameter = sortOrder
      section.sort()
      this.renderContents()
      
    
    setSortOrderToNext: (param) ->
      section = WatchlistSectionCollections[this.options.section]

      if param == section.sortByParameter
        param = param + "Desc"
      else if param == section.sortByParameter.substr(0, section.sortByParameter.length - 4)
        param = "lastWatchedDesc"
        
      this.setSortOrder param
      
    renderContents: ->
      tbody = $("<tbody class='fake-table-row library-item'></tbody>")
      this.collection.each (i) ->
        tbody.append i.get("_view").render().el
      $("#table-" + this.options.section + " .library-item").replaceWith tbody

  # Bind each WatchlistSectionCollection to corresponding view.
  WatchlistSectionViews = {}
  _.each WatchlistSections, (s) ->
    WatchlistSectionViews[s] = new WatchlistSectionViewClass
      collection: WatchlistSectionCollections[s]
      section: s
    WatchlistSectionViews[s].render()
    if $.jStorage.get("sortOrder_" + s)
      WatchlistSectionViews[s].setSortOrder $.jStorage.get("sortOrder_" + s)

  lastRender = moment()
  perPage = 100
  @fetchWatchlistSection = (s...) ->
    section = s[0]
    page = if s[1] then s[1] else 1
    watchlist_path = "/api/v1/users/#{@user.to_param}/library"
    $.getJSON(watchlist_path + "?status=" + section + "&page=" + page, (d) ->
      models = _.map d, (x) ->
        new WatchlistItem x
      WatchlistSectionCollections[section].set models, {remove: false}
      if d.length == perPage
        $("#table-" + section + " .loading-indicator span span").text(page * perPage)
        fetchWatchlistSection section, page+1
      else
        WatchlistSectionViews[section].renderContents()
        $("#table-" + section + " .loading-indicator").hide())
      .error ->
        setTimeout('fetchWatchlistSection("' + section + '", ' + page + ')', 2000)

  _.each WatchlistSections, (s) ->
    fetchWatchlistSection(s)
