- title "#{@user.name}'s Anime Library"

.large-12.columns.watchlist-option-bar
  .large-2.columns
    %p.option-title Anime Library
  .large-9.columns.options
    %ul.status-tabs.inline-list
      %li.active#tab-all= link_to "All", "#all", onclick: "showRelevantSections('all')"
      - Watchlist.valid_statuses.each do |status|
        %li{:id => "tab-" + status.parameterize}= link_to status, "##{status.parameterize}", onclick: "showRelevantSections(#{status.parameterize.inspect})"

- Watchlist.valid_statuses.each do |status|
  .watchlist-row{:id => "table-" + status.parameterize}
    .large-12.columns.library-status-header
      %h5.status= status
    .row
      .large-12.columns.library-table

%script(type="text/template" id="WatchlistSectionViewTemplate")
  %table.large-12.columns.fake-table-row
    %thead
      %tr
        %th{:width => "505"}= link_to "Title", "#"#, :class => "active"
        %th{:width => "95"}= link_to "Progress", "#"
        %th{:width => "68"}= link_to "Rating", "#"
        %th{:width => "65"}= link_to "Type", "#"

    %tbody.fake-table-row.library-item

    %tbody.loading-indicator
      %tr
        %td.center(colspan=4 style="color: #333")
          %i.icon.icon-spin.icon-spinner.icon-2x
          %span.right(style="color: #aaa; padding-top: 10px")
            (Finished loading <span>0</span> entries.)

%script(type="text/template" id="WatchlistItemViewTemplate")
  %td.library-item-title{:width => "505"}
    .relative-wrapper
      %a{:href => "{{anime.url}}"} {{anime.title}}
      {{#private}}
      %span.private-indicator [PRIVATE]
      {{/private}}
      %i.icon-reorder
  %td.episode-count{:width => "95"}
    .relative-wrapper 
      <a href="#" class="click-add"><i class="icon-angle-up"></i></a>
      <span class="edit">{{episodes_watched}}</span> / {{anime.episode_count}}
  %td{:width => "68"} 
    %span.select
      - if @user.star_rating
        %i.icon-star
        {{rating.value}}
      - else
        {{#rating.positive}}
        %span.positive-smiley :)
        {{/rating.positive}}
        {{#rating.neutral}}
        %span.neutral-smiley :|
        {{/rating.neutral}}
        {{#rating.negative}}
        %span.negative-smiley :(
        {{/rating.negative}}
        {{#rating.unknown}}
        %span.unknown-smiley ?
        {{/rating.unknown}}
  %td{:width => "65"} {{anime.show_type}}
  
%script(type="text/template" id="WatchlistDropdownTemplate")
  %tr.library-dropdown
    %td{:style => "background: #fafafa;"}(colspan=4)
      .large-8.columns.meta-content
        .large-12.columns.last-update
          %p Last Library Update: {{formattedLastUpdateTime}}
        .large-3.columns.thumbnail
          %img(src="{{anime.cover_image}}")
        
        // Left side of dropdown with thumbnail and description
        .large-9.columns.library-item-info
          %span.title {{anime.title}}
          .rating
          %span.description {{anime.short_synopsis}}
          %span.description-link
            %a{:style => "color: #fd864b;"}(href="{{anime.url}}") [Read More]

      // Right side of dropdown with update content
      .large-4.columns.action-area
        .opacity-wrapper
          %form.custom
            .large-12.columns.library-status
              .large-3.columns.option-label
                %span Status:
              .large-9.columns.status-dropdown
                %select.medium(name="status")
                  - Watchlist.valid_statuses.each do |status|
                    %option{:value => status.parameterize}= status

            .large-12.columns.episodes-watched
              .large-3.columns.option-label
                %span Watched:
              .large-9.columns.status-dropdown
                .large-6.columns.episode-input
                  %input#watchlist_episodes_watched{:max => "1", :min => "0", :name => "watchlist[episodes_watched]", :type => "number", :value => "1"}/
                  / = f.number_field :episodes_watched, :min => 0, :max => watchlist.anime.episode_count
                .large-6.columns.end.episode-count
                  %span.postfix Out of 25
                

            .large-12.columns.privacy-setting
              .large-3.columns.option-label
                %span Privacy:
              .large-9.columns.privacy-dropdown
                %select.medium(name="privacy")
                  %option(value="public") Public
                  %option(value="private") Private

          .large-12.columns.remove-from-library.text-center
            %span
              %i.icon-remove
              %a.remove-from-library Remove From Library
        // Spinner
        %span.updating-icon.hide
          %i.icon-spinner.icon-spin.updating-icon
            
            
:coffee
  starRatings = #{@user.star_rating.inspect}

  setActiveTab = (section) ->
    $(".watchlist-option-bar .options li").removeClass "active"
    $(".watchlist-option-bar .options #tab-" + section).addClass "active"

  WatchlistSections = #{Watchlist.valid_statuses.map {|x| x.parameterize }.inspect}
    
  @showRelevantSections = (x...) ->
    section = if x[0] then x[0] else window.location.hash.substring(1)
    if _.contains WatchlistSections, section
      setActiveTab section
      $(".watchlist-row").hide()
      $("#table-" + section).show()
    else
      setActiveTab "all"
      $(".watchlist-row").show()
      
  showRelevantSections()

  # Models and Collections
  WatchlistItem = Backbone.Model.extend
    update: (d) ->
      oldSection = this.get("status_parameterized")
      newSection = d.status_parameterized
      WatchlistSectionCollections[oldSection].remove d
      WatchlistSectionCollections[newSection].add d
      WatchlistSectionViews[newSection].renderContents()
      return WatchlistSectionCollections[newSection].get d.id

  WatchlistSectionCollections = {}
  _.each WatchlistSections, (s) ->
    WatchlistSectionCollections[s] = new Backbone.Collection []

  # Views
  WatchlistItemView = Backbone.View.extend
    tagName: "tr"
    template: Hogan.compile $("#WatchlistItemViewTemplate").html()
    dropdownTemplate: Hogan.compile $("#WatchlistDropdownTemplate").html()

    initialize: ->
      _(this).bindAll 'remove', 'change'
      this.model.bind 'remove', this.remove
      this.model.bind 'change', this.change

    remove: ->
      this.hideDropdown()
      this.$el.remove()

    change: ->
      if this.model.get("_dropdownOpen")
        this.showDropdown()
      else
        this.hideDropdown()
    
    render: ->
      this.model.set "formattedLastUpdateTime", moment(this.model.get("last_watched")).format('MMMM Do YYYY')
      this.$el.html this.template.render this.model.toJSON()
      that = this
      this.$el.find("td:first").click ->
        that.toggleDropdown()
      return this
      
    showDropdown: ->
      that = this
      WatchlistSectionCollections[this.model.get("status_parameterized")].find (m) ->
        if m.get("_dropdownOpen") and m.get("_id") != that.model.get("_id")
          m.set "_dropdownOpen", false
      this.$el.after this.dropdownTemplate.render this.model.toJSON()

      dropdown = this.$el.next()
      # Write rating to the dropdown.
      dropdown_ratings = dropdown.find ".rating"
      dropdown_ratings.empty()
      rating = this.model.get("rating")
      if starRatings
        for i in [-2..2]
          if rating.value >= i + 3
            dropdown_ratings.append $("<i class='icon-star'></i>")
          else
            dropdown_ratings.append $("<i class='icon-star-empty'></i>")
      else
        m = {
          positive: "<span class='positive-smiley'>:)</span>", 
          neutral: "<span class='neutral-smiley'>:|</span>", 
          negative: "<span class='negative-smiley'>:(</span>"
        }
        for t in ['positive', 'neutral', 'negative']
          if rating[t]
            dropdown_ratings.append "<strong>" + m[t] + "</strong>"
          else
            dropdown_ratings.append m[t]

      # Set status and privacy.
      dropdown.find("option[value=" + this.model.get("status_parameterized") + "]").attr("selected", "selected")
      dropdown.find("option[value=" + (if this.model.get("private") then "private" else "public") + "]").attr("selected", "selected")

      that = this
      # Activate "Remove from Library" button.
      dropdown.find(".remove-from-library").click ->
        that.dropdownLoading()

        $.post "/watchlist/remove", {anime_id: that.model.get("anime").slug}, (d) ->
          if d
            status = that.model.get("status_parameterized")
            WatchlistSectionCollections[status].remove that.model
            WatchlistSectionViews[status].renderContents()

      # Submit updates when needed.
      dropdown.find("form.custom").submit -> return false
      dropdown.find("form.custom").change ->
        that.dropdownLoading()
        data = {anime_id: that.model.get("anime").slug}
        _.each dropdown.find("form.custom").serializeArray(), (x) ->
          data[x.name] = x.value
        $.post "/watchlist/update", data, (d) ->
          that.model.update(d).set "_dropdownOpen", true

    dropdownLoading: ->
      $(".opacity-wrapper").addClass("updating")
      $(".updating-icon").removeClass("hide")

    hideDropdown: ->
      this.$el.next().slideUp().remove()

    toggleDropdown: ->
      if this.model.get("_dropdownOpen")
        this.model.set "_dropdownOpen", false
      else
        this.model.set "_dropdownOpen", true

  WatchlistSectionViewClass = Backbone.View.extend
    tagName: "div"
    template: Hogan.compile $("#WatchlistSectionViewTemplate").html()
    initialize: ->
      _(this).bindAll 'add'
      this.collection.bind 'add', this.add
    add: (i) ->
      iv = new WatchlistItemView {model: i}
      i.set "_view", iv
    render: ->
      this.$el.html this.template.render()
      $("#table-" + this.options.section + " .library-table").append this.el
      return this
    renderContents: ->
      tbody = $("<tbody class='fake-table-row library-item'></tbody>")
      this.collection.each (i) ->
        tbody.append i.get("_view").render().el
      $("#table-" + this.options.section + " .library-item").replaceWith tbody

  # Bind each WatchlistSectionCollection to corresponding view.
  WatchlistSectionViews = {}
  _.each WatchlistSections, (s) ->
    WatchlistSectionViews[s] = new WatchlistSectionViewClass
      collection: WatchlistSectionCollections[s]
      section: s
    WatchlistSectionViews[s].render()

  lastRender = moment()
  perPage = 50
  @fetchWatchlistSection = (s...) ->
    section = s[0]
    page = if s[1] then s[1] else 1
    watchlist_path = #{user_watchlist_path(@user, format: :json).inspect}
    $.getJSON(watchlist_path + "?list=" + section + "&page=" + page, (d) ->
      models = _.map d, (x) ->
        new WatchlistItem x
      WatchlistSectionCollections[section].set models, {remove: false}
      if d.length > 0
        $("#table-" + section + " .loading-indicator span span").text(page * perPage)
        fetchWatchlistSection section, page+1
      else
        WatchlistSectionViews[section].renderContents()
        $("#table-" + section + " .loading-indicator").hide())
      .error ->
        setTimeout('fetchWatchlistSection("' + section + '", ' + page + ')', 2000)

  _.each WatchlistSections, (s) ->
    fetchWatchlistSection(s)
